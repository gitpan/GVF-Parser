.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GVF::Parser 3"
.TH GVF::Parser 3 "2012-12-30" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GVF::Parser \- A parser for Genome Variation Format files.
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Takes a given \s-1GVF\s0 file and creates a DBIx::Class sqlite3 database.  In addition to having the ability to retrive sections of pragma and feature data directly via methods provided.
.PP
This module is not intended to provide a method to do complex analysis with \s-1GVF\s0 data, but to provide a manner to parse desired data out or in cordonation with a user pipeline.
.PP
GVF::Parser partitions \s-1GVF\s0 files into pragma and feature data, and the feature data is further split into features and attributes.  Pragma data is stored in object, and can be requested using the provided methods.  Attribute information is stored/saved in a sqlite datafile, and can be accessed using the attributeRequest method, or more via DBIx::Class.
.PP
This parser looks at feature line data in the following way:
.PP
.Vb 3
\&                                 features                                                                attributes
\&|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-||\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&chr16   samtools        SNV     49291141        49291141        .       +       .        ID=ID_1;Variant_seq=A,G;Reference_seq=G;
.Ve
.PP
featureRequest calls will access the first eight elements of a feature line, and attributeRequest calls encompass the eighth column.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use GVF::Parser;
\&
\&        # Add unsupported attributes to the database. Currently five extra tags are allowed
\&
\&        # Example:
\&        my $unsupported = {
\&            add_attribute1 => \*(Aqhgmd_disease\*(Aq,
\&            add_attribute2 => \*(Aqhgmd_location\*(Aq,
\&        };
\&
\&        my $obj = GVF::Parser\->new(
\&            file           => $gvf,          # required
\&            file_modifier  => $unsupported,  # pass the unsupported tags to GVF::Parser
\&        );
\&
\&        # pragmas are stored in the object
\&        # features are use to build sqlite database
\&
\&        $obj\->pragmas;
\&        $obj\->features;
\&
\&        #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&                
\&        # Example one
\&        # DBIx::Class approach.
\&        
\&        # connection to db via DBIx::Class object
\&        my $dbix       = $obj\->get_dbixclass;
\&        
\&        # use DBIx::Class as standard from this point.
\&        my $features   = $dbix\->resultset(\*(AqFeatures\*(Aq);
\&        my $attributes = $dbix\->resultset(\*(AqAttributes\*(Aq);
\&        
\&        # create a hash of all the feature items wanted
\&        # using feature table primary key
\&        my %feats;
\&        while (my $f = $features\->next){
\&            $feats{ $f\->id } = {
\&                type  => $f\->type,
\&                start => $f\->start,
\&                end   => $f\->end,
\&            };
\&        }
\&
\&        # use attribure resultset to access desired parts of file
\&        # using attributes foreign_key to maintain relationship with features
\&        while (my $a = $attributes\->next ){
\&            if ( $feats{ $a\->features_id } ){
\&                
\&                my $varInfo = $obj\->tidyVariantEffect( $a\->varianteffect);
\&        
\&                foreach my $i ( @{$varInfo} ){
\&                    if ( $i\->{sequence_variant} eq \*(Aqframeshift_variant\*(Aq ) {
\&                        print $i\->{\*(Aqfeature_type\*(Aq}, "\et";
\&                        print $i\->{\*(Aqfeature_id\*(Aq}, "\et";
\&                        print $feats{ $a\->features_id }\->{\*(Aqstart\*(Aq}, "\et";
\&                        print $feats{ $a\->features_id }\->{\*(Aqtype\*(Aq}, "\et";
\&                        print $a\->referenceseq, "\et";
\&                        print $a\->variantseq, "\en";
\&                    }
\&                }
\&            }
\&        }
\&
\&        #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&        # Example two.
\&        # accessing data in parts
\&        
\&        # Example of using request methods.
\&        my $feats   = $obj\->featureRequest(\*(Aqseqid\*(Aq);
\&        my $atts    = $obj\->attributeRequest(\*(AqVariant_effect\*(Aq);
\&        my @regions = $obj\->sequenceRegions;
\&        
\&        # pragma can be requested with list or individually.
\&        my @wantList  = qw/ multi\-individual population data\-source /;
\&        my $foundList = $obj\->pragmaRequest(\e@wantList);
\&        my $foundMore = $obj\->pragmaRequest(\*(Aqdata\-source\*(Aq);
\&        my $foundprag = $obj\->getAllPragmas;
\&        my @foundIndv = $obj\->pragmaRequest(\*(Aqdata\-source\*(Aq);
\&        
\&        #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "pragmas"
.IX Subsection "pragmas"
.Vb 4
\&    Title    : pragmas
\&    Usage    : $obj\->pragmas
\&    Function : Build pragma data into the object.
\&    Returns  : None.
\&
\& Pragma data is stored in object and requested via pragmaRequest, getAllPragmas.
.Ve
.SS "features"
.IX Subsection "features"
.Vb 4
\&    Title    : features
\&    Usage    : $obj\->features
\&    Function : Builds a SQLite3 database of feature values.
\&    Returns  : None
\&
\& This will populate a sqlite3 database creating a features and attributes table, parts of which can be accessed via featureRequest or attributeRequest.
.Ve
.SS "getAllPragmas"
.IX Subsection "getAllPragmas"
.Vb 4
\&    Title    : getAllPragmas
\&    Usage    : $obj\->getAllPragmas
\&    Function : Retrieves a hash of all pragmas and values in a given file.
\&    Returns  : hash or (reference) of "pragma => value".
\&
\& Simple pragmas values are returned as simple key values pair e.g. gvf_version => \*(Aq1.06\*(Aq, and structured pragma are returned as hash of hash e.g. data_source => { \*(AqType\*(Aq => \*(AqSNV\*(Aq }
.Ve
.SS "pragmaRequest"
.IX Subsection "pragmaRequest"
.Vb 5
\&    Title    : pragmaRequest
\&    Usage    : $wanted = $obj\->pragmaRequest($request) or
\&               $wanted = $obj\->pragmaRequest($arrayref)
\&    Function : Capture requested pragma term
\&    Returns  : Array or (reference) of requested pragma term in its original form.  Structured pragmas are not further broken down.
\&
\& This method allow you to request only a specfic pragma term, or a list of terms passed as an array reference.  All are returned in original form.
.Ve
.SS "sequenceRegions"
.IX Subsection "sequenceRegions"
.Vb 4
\&    Title    : sequenceRegions
\&    Usage    : $regions = $obj\->sequenceRegions
\&    Function : Capture all sequence regions from a GVF file.
\&    Returns  : Arrayref of all sequence regions.
.Ve
.SS "featureRequest"
.IX Subsection "featureRequest"
.Vb 4
\&    Title    : featureRequest
\&    Usage    : $features = $obj\->featureRequest(\*(Aqseqid\*(Aq);
\&    Function : Caputre requested feature types.
\&    Returns  : Returns array or (reference) of requested feature.
.Ve
.SS "attributeRequest"
.IX Subsection "attributeRequest"
.Vb 4
\&    Title    : attributeRequest
\&    Usage    : $attributes = $obj\->attributeRequest(\*(Aqreference_seq\*(Aq);
\&    Function : Caputre requested attribute type.
\&    Returns  : Returns array or (reference) of requested attribute.
.Ve
.SS "tidyVariantEffect"
.IX Subsection "tidyVariantEffect"
.Vb 6
\&    Title    : tidyVariantEffect
\&    Usage    : $effect = $obj\->tidyVariantEffect( "variant_effect line" ); 
\&    Function : Will take individual Variant_effect from feature line and return
\&               line as hashref of each space delimited field.
\&    Returns  : array of hashref or (arrayref of hashref) of variant effects. 
\&    Args     : Individual Variant_effect line.
\&
\& This method is only designed to work with an individual Variant_effect from a feature line.  It use is not needed when using attributeRequest as that method preform the tidying for you.
\&
\& Example of method return:
\& 
\&    {
\&        feature_id         "CM990001",
\&        feature_type       "mRNA",
\&        index              0,
\&        sequence_variant   "coding_sequence_variant"
\&    },
\&
\& The hashref\*(Aqs keys will always be as the example shows.  Please see "Example one DBIx::Class approach for individual usage example.
.Ve
.SS "get_dbixclass"
.IX Subsection "get_dbixclass"
.Vb 4
\&    Title    : get_dbixclass
\&    Usage    : $obj\->get_dbixclass
\&    Function : Handle used to connect to DBIx::Class
\&    Returns  : DBIx::Class object
\&
\& When assigning resultset the sqlite3 column names for features are the first eight columns of a feature line, and attribute columns are the allow GVF column names, lowercased with no underscores, e.g. referencecodon.
\& Also allow are the five "added_attribute1" which can be added at object construction, and feature_id which is the foreign key to the feature table.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Please contact me with any issue, method ideas/improvments or documentation matters.
.PP
Shawn Rynearson, \f(CW\*(C`<shawn.rynerson at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-gvf\-parser at rt.cpan.org\*(C'\fR, or through
the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=GVF\-Parser <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=GVF-Parser>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
.Vb 1
\&    perldoc GVF::Parser
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker (report bugs here)
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=GVF\-Parser <http://rt.cpan.org/NoAuth/Bugs.html?Dist=GVF-Parser>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/GVF\-Parser <http://annocpan.org/dist/GVF-Parser>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/GVF\-Parser <http://cpanratings.perl.org/d/GVF-Parser>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/GVF\-Parser/ <http://search.cpan.org/dist/GVF-Parser/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
This module would not be complete with out acknowledging all the help I've had from the \s-1SO\s0 community, special thanks to Barry Moore for ideas and guidance.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 Shawn Rynearson.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
