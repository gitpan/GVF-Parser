.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "GVF::Parser 3"
.TH GVF::Parser 3 "2012-12-08" "perl v5.12.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
GVF::Parser \- A parser for Genome Variation Format files.
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use GVF::Parser;
\&
\&        # Add unsupported attributes to the database. Currently five extra tags are allowed
\&
\&        # Example:
\&        my $unsupported = {
\&            add_attribute1 => \*(Aqhgmd_disease\*(Aq,
\&            add_attribute2 => \*(Aqhgmd_location\*(Aq,
\&        };
\&
\&        my $obj = GVF::Parser\->new(
\&            file           => $gvf,          # required
\&            file_modifier  => $unsupported,  # pass the unsupported tags to GVF::Parser
\&        );
\&
\&        # pragmas are stored in the object
\&        # features are use to build sqlite database
\&
\&        $obj\->pragmas;
\&        $obj\->features;
\&
\&        #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&        # Example one
\&        # DBIx::Class approach.
\&
\&        # connection to db via DBIx::Class object
\&        my $dbi = $obj\->get_dbixclass;
\&
\&        # a simple example using DBIx::Class.
\&        my $features   = $dbi\->resultset(\*(AqFeatures\*(Aq);
\&        my $attributes = $dbi\->resultset(\*(AqAttributes\*(Aq);
\&
\&        # create a hash of all the feature items wanted
\&        # using feature table primary key
\&        my %feats;
\&        while (my $f = $features\->next) {
\&            $feats{ $f\->id } = {
\&                type  => $f\->type,
\&                start => $f\->start,
\&                end   => $f\->end,
\&            };
\&        }
\&
\&        # use attribure resultset to access desired parts of file
\&        # using attributes foreign_key to maintain relationship with features
\&        while (my $i = $attributes\->next ){
\&            if ( $feats{ $i\->features_id } ){
\&                my $varInfo = $obj\->effectHash( $i\->varianteffect );
\&
\&                if ( $varInfo\->{\*(Aqthree_prime_UTR_variant\*(Aq}) {
\&                        print $varInfo\->{\*(Aqthree_prime_UTR_variant\*(Aq}\->{\*(Aqfeature_type\*(Aq}, "\et";
\&                        print $varInfo\->{\*(Aqthree_prime_UTR_variant\*(Aq}\->{\*(Aqfeature\*(Aq}, "\et";
\&                        print $feats{ $i\->features_id }\->{\*(Aqstart\*(Aq}, "\et";
\&                        print $feats{ $i\->features_id }\->{\*(Aqtype\*(Aq}, "\et";
\&                        print $i\->referenceseq, "\et";
\&                        print $i\->variantseq, "\en";
\&                }
\&            }
\&        }
\&
\&        #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&        # Example two.
\&        # accessing data in parts
\&
\&        # Example of using request methods.
\&        my @feats   = $obj\->featureRequest(\*(Aqseqid\*(Aq, \*(Aquniq\*(Aq);
\&        my @atts    = $obj\->attributeRequest(\*(AqVariant_effect\*(Aq);
\&        my $regions = $obj\->sequenceRegions;
\&
\&        # pragma can be requested with list or individually.
\&        my @wantList  = qw/ multi\-individual population  /;
\&        my $foundList = $obj\->pragmaRequest(\e@list);
\&        my $foundIndv = $obj\->pragmaRequest(\*(Aqgvf\-version\*(Aq);
\&
\&        #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Takes a given \s-1GVF\s0 file and creates a DBIx::Class sqlite3 database.  In addition to having the ability to retrive sections of pragma and feature data directly via methods provided.
.PP
GVF::Parser partitions \s-1GVF\s0 files into pragma and feature data, and the feature data is further split into features and attributes.  Pragma data is stored in object, and can be requested using the pragmaRequest method.  Attribute information is stored/saved in a sqlite datafile, and can be accessed using the attributeRequest method, or more preferably via DBIx::Class requestset
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "pragmas"
.IX Subsection "pragmas"
.Vb 3
\&    Title    : pragmas
\&    Usage    : $obj\->pragmas
\&    Returns  : None.
\&
\& Pragma data is stored in object and requested via <L<https://metacpan.org/module/GVF::Parser#pragmaRequest> or <L<https://metacpan.org/module/GVF::Parser#getPragma>
.Ve
.SS "features"
.IX Subsection "features"
.Vb 4
\&    Title    : features
\&    Usage    : $obj\->features
\&    Function : Builds a SQLite3 database of feature values.
\&    Returns  : None
\&
\& This will populate a sqlite3 database creating a features and attributes table, parts of which can be accessed via <L<https://metacpan.org/module/GVF::Parser#featureRequest> or <L<https://metacpan.org/module/GVF::Parser#attributeRequest>
.Ve
.SS "getPragma"
.IX Subsection "getPragma"
.Vb 4
\&    Title    : getPragma
\&    Usage    : $obj\->getPragmas($pragma)
\&    Function : Allow you to search for a specific pragma.
\&    Returns  : requested pragma
\&
\& Allows you to search for a single pragma key.  <L<https://metacpan.org/module/GVF::Parser#pragmaRequest> offers more functionality.
.Ve
.SS "pragmaKeys"
.IX Subsection "pragmaKeys"
.Vb 4
\&    Title    : pragmaKeys
\&    Usage    : $obj\->pragmaKeys
\&    Function : Grabs a list of all pragma keys in a given file
\&    Returns  : Array of all pragma keys
.Ve
.SS "pragmaValues"
.IX Subsection "pragmaValues"
.Vb 4
\&    Title    : pragmaValues
\&    Usage    : $obj\->pragmaValues
\&    Function : Grabs a list of all pragma values in a given file
\&    Returns  : Array of all pragma values
.Ve
.SS "pragmaRequest"
.IX Subsection "pragmaRequest"
.Vb 6
\&    Title    : pragmaRequest
\&    Usage    : $wanted = $obj\->pragmaRequest($request) or
\&               $wanted = $obj\->pragmaRequest(\e@arrayref)
\&    Function : Capture requested simple pragma term
\&    Returns  : Single request returns arrayref of value.
\&               Passing list returns arrayref of all values.
.Ve
.SS "sequenceRegions"
.IX Subsection "sequenceRegions"
.Vb 4
\&    Title    : sequenceRegions
\&    Usage    : $regions = $obj\->sequenceRegions
\&    Function : Capture all sequence regions from a GVF file.
\&    Returns  : Arrayref of all sequence regions.
.Ve
.SS "featureRequest"
.IX Subsection "featureRequest"
.Vb 6
\&    Title    : featureRequest
\&    Usage    : @features = $obj\->featureRequest(\*(Aqseqid\*(Aq);
\&               @features = $obj\->featureRequest(\*(Aqseqid\*(Aq, \*(Aquniq\*(Aq);
\&    Function : Caputre requested feature types
\&    Returns  : Returns array of requested features or,
\&               returns array of uniq features of requested type
.Ve
.SS "attributeRequest"
.IX Subsection "attributeRequest"
.Vb 6
\&    Title    : attributeRequest
\&    Usage    : @attributes = $obj\->attributeRequest(\*(Aqreference_seq\*(Aq);
\&               $attributes = $obj\->attributeRequest(\*(Aqreference_seq\*(Aq, \*(Aquniq\*(Aq);
\&    Function : Caputre requested attribute type.
\&    Returns  : Returns array of requested attribute types, or
\&               returns array of uniq attributes of requested type
.Ve
.SS "tidyVariantEffect"
.IX Subsection "tidyVariantEffect"
.Vb 6
\&    Title    : tidyVariantEffect
\&    Usage    : $wanted = $obj\->tidyVariantEffect( "variant_effect line" ); 
\&    Function : Will take individual Variant_effect line and return  
\&               hashref of each feature type.
\&    Returns  : Hashref of Variant_effect. 
\&    Args     : Individual Variant_effect line.
\&
\& Example  :
\&       From DBIx::Class resultset:
\&       my $varInfo = $obj\->tidyVariantEffect( $result\->varianteffect );
\&       
\& Results:
\& $_ = {
\&          \*(Aqcoding_sequence_variant\*(Aq => {
\&                                         \*(Aqfeature_type\*(Aq => \*(AqmRNA\*(Aq,
\&                                         \*(Aqindex\*(Aq => \*(Aq0\*(Aq,
\&                                         \*(Aqfeature_id\*(Aq => \*(AqNM_000271\*(Aq
\&                                       },
\&          \*(Aqframeshift_variant\*(Aq => {
\&                                    \*(Aqfeature_type\*(Aq => \*(AqmRNA\*(Aq,
\&                                    \*(Aqindex\*(Aq => \*(Aq0\*(Aq,
\&                                    \*(Aqfeature_id\*(Aq => \*(AqNM_000271\*(Aq
\&                                  },
\&          \*(Aqgene_variant\*(Aq => {
\&                              \*(Aqfeature_type\*(Aq => \*(Aqgene\*(Aq,
\&                              \*(Aqindex\*(Aq => \*(Aq0\*(Aq,
\&                              \*(Aqfeature_id\*(Aq => \*(AqNPC1\*(Aq
\&                            }
\&        };
.Ve
.SS "get_dbixclass"
.IX Subsection "get_dbixclass"
.Vb 4
\&    Title    : get_dbixclass
\&    Usage    : $obj\->get_dbixclass
\&    Function : Handle, used to connect to DBIx::Class
\&    Returns  : DBIx::Class object
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Shawn Rynearson, \f(CW\*(C`<shawn.rynerson at gmail.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests to \f(CW\*(C`bug\-gvf\-parser at rt.cpan.org\*(C'\fR, or through
the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=GVF\-Parser <http://rt.cpan.org/NoAuth/ReportBug.html?Queue=GVF-Parser>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.
.SH "SUPPORT"
.IX Header "SUPPORT"
.Vb 1
\&    perldoc GVF::Parser
.Ve
.PP
You can also look for information at:
.IP "\(bu" 4
\&\s-1RT:\s0 \s-1CPAN\s0's request tracker (report bugs here)
.Sp
http://rt.cpan.org/NoAuth/Bugs.html?Dist=GVF\-Parser <http://rt.cpan.org/NoAuth/Bugs.html?Dist=GVF-Parser>
.IP "\(bu" 4
AnnoCPAN: Annotated \s-1CPAN\s0 documentation
.Sp
http://annocpan.org/dist/GVF\-Parser <http://annocpan.org/dist/GVF-Parser>
.IP "\(bu" 4
\&\s-1CPAN\s0 Ratings
.Sp
http://cpanratings.perl.org/d/GVF\-Parser <http://cpanratings.perl.org/d/GVF-Parser>
.IP "\(bu" 4
Search \s-1CPAN\s0
.Sp
http://search.cpan.org/dist/GVF\-Parser/ <http://search.cpan.org/dist/GVF-Parser/>
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 Shawn Rynearson.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
